# Memolog テスト方針書

## 目的

本ドキュメントは、Memologプロジェクトにおけるテスト駆動開発(TDD)の方針を定め、テストの品質を向上させることを目的とする。

### TDDの根本目的

TDDの根本目的は、**安心して変更できる状態を維持する**ことである。

- 自動テストにより、コードが正しく動作することを継続的に保証する。
- リファクタリングや機能追加時に、既存機能が壊れていないことを即座に検知できる。
- 「このコードを変更しても大丈夫か」という不安から解放される。
- 変更に強いコードベースを構築し、長期的な保守性を確保する。

### テストの品質に対する考え方

テストの数ではなく、1つ1つのテストの品質を重視し、確認すべき事項が漏れなく確認できることを目指す。

- テストカバレッジ100%が目標ではない。
- 重要なのは「正しい振る舞いをテストしているか」である。
- 1つのテストで1つのことだけをテストする。
- テストコードは「生きた仕様書」として機能する。

## TDD基本原則

### Red-Green-Refactorサイクル

TDDの基本サイクルは、Red → Green → Refactor の3ステップを小刻みに繰り返すことである。

1. **Red: 失敗するテストを書く**
   - 新しい機能や振る舞いに対して、まず失敗するテストを書く。
   - テストが失敗することを確認してから次のステップに進む。
   - テストは「あるべき振る舞い」を記述する。

2. **Green: 最小限の実装でテストを通す**
   - テストを通すために必要最小限のコードを実装する。
   - 余計な実装は避け、テストが通ることだけを目指す。
   - **重要: テストが通るまでの最小ステップを意識する**。
     - 一度に多くの実装を追加しない。
     - 1つのテストが通ったら、次のテストに進む。
     - 「仮実装 → 三角測量 → 実装の一般化」のステップを踏む。

3. **Refactor: コードを改善する**
   - テストが通った状態を保ちながら、コードの可読性や保守性を向上させる。
   - 過度なリファクタリングは避け、適切なタイミングで行う。
   - テストコード自体もリファクタリングの対象とする。

### 最小ステップの重要性

TDDでは、各Red-Greenサイクルを可能な限り小さく保つことが重要である。

**なぜ最小ステップが重要か:**

- バグの混入を最小限に抑えられる。
- 問題が発生した時の原因特定が容易になる。
- 常にテストが通る状態を保てる(安心感)。
- 設計の誤りに早期に気づける。

**最小ステップの例:**

```typescript
// ステップ1: 最も単純なケースのテスト(Red)
it("空配列をフィルタリングすると空配列を返す", () => {
	expect(filterMemos([], "today")).toEqual([])
})

// ステップ1の実装(Green): 仮実装
function filterMemos(memos, range) {
	return []
}

// ステップ2: 次のケースのテスト(Red)
it("1件のメモをフィルタリングすると1件を返す", () => {
	const memos = [createTestMemo("memo-1", TODAY, "テスト")]
	expect(filterMemos(memos, "today")).toHaveLength(1)
})

// ステップ2の実装(Green): 三角測量
function filterMemos(memos, range) {
	return memos
}

// ステップ3: 範囲外のメモを除外するテスト(Red)
it("範囲外のメモは除外される", () => {
	const memos = [
		createTestMemo("memo-1", YESTERDAY, "昨日"),
		createTestMemo("memo-2", TODAY, "今日"),
	]
	const result = filterMemos(memos, "today")
	expect(result).toHaveLength(1)
	expect(result[0].id).toBe("memo-2")
})

// ステップ3の実装(Green): 実装の一般化
function filterMemos(memos, range) {
	const { start, end } = getDateRange(range)
	return memos.filter(memo => {
		const memoDate = new Date(memo.timestamp)
		return memoDate >= start && memoDate <= end
	})
}
```

### テストリスト駆動

1. **振る舞いに焦点を当てる**
   - テストリストを作成する際は、「どう実装するか」ではなく「どう振る舞うか」に焦点を当てる。
   - インターフェース(外部仕様)と実装(内部構造)を分離して考える。

2. **テストリストの作成**
   - 新しい機能を追加する前に、テスト対象となるシナリオを列挙する。
   - 「こういう振る舞いが期待される」「こういう場合に壊れたくない」という観点でリストアップする。

3. **ひとつずつ進める**
   - テストリストから1つずつテストを選び、Red-Green-Refactorサイクルを回す。
   - 並行して複数のテストを実装しない。

## テスト構造の原則

### AAA(Arrange-Act-Assert)パターン

全てのテストは以下の3つのセクションで構成する。

1. **Arrange(準備)**
   - テストに必要なデータやモックを準備する。
   - テスト対象の初期状態を設定する。

2. **Act(実行)**
   - テスト対象の機能を実行する。
   - 1つのテストでは1つのアクションのみを実行する。

3. **Assert(検証)**
   - 期待される結果を検証する。
   - 検証内容は明確で具体的であるべき。

### テストの独立性

- 各テストは独立して実行可能であること。
- テスト間で状態を共有しない。
- beforeEach/afterEachを使用して、各テストの前後で状態をクリーンにする。

### 命名規約

- テストケースの説明は日本語で記述する。
- 「〜できる」「〜を返す」「〜の場合、〜する」という形式で記述する。
- 期待される振る舞いが明確に分かる名前にする。

例:

```typescript
it("メモを新規作成できる", async () => { ... });
it("存在しないメモを取得するとnullを返す", async () => { ... });
it("日付範囲フィルターが有効な場合、範囲外のメモは除外される", async () => { ... });
```

## テストピラミッド: ユニットテスト重視の原則

テストは、テストピラミッドに従って構成する。**ユニットテストを基盤とし、上位レイヤーのテストは必要最小限に留める**。

```
      /\
     /  \      E2E Test (少数)
    /----\
   /      \    Integration Test (中程度)
  /--------\
 /          \  Unit Test (多数)
/____________\
```

### テストピラミッドの原則

1. **ユニットテストが基盤**
   - テストの大部分はユニットテストで構成する(目安: 全体の70-80%)。
   - 高速に実行でき、失敗時の原因特定が容易。
   - 外部依存をモック化し、テスト対象のロジックのみに集中する。

2. **統合テストは中程度**
   - 複数のコンポーネント間の連携をテストする(目安: 全体の15-20%)。
   - ユニットテストでカバーできない連携部分のみをテストする。
   - 実行時間が長くなることを許容するが、過度に複雑にしない。

3. **E2Eテストは少数**
   - ユーザーの操作フローを再現するテスト(目安: 全体の5-10%)。
   - 最も重要なシナリオのみをテストする。
   - 実行時間が長く、メンテナンスコストが高いため、必要最小限に留める。

### なぜユニットテスト重視なのか

- **高速**: 1テスト数ミリ秒で実行できる。開発者のフィードバックループが速い。
- **信頼性**: 外部依存がないため、テストが不安定になりにくい。
- **保守性**: テストが小さく、意図が明確。修正が容易。
- **設計改善**: ユニットテスタブルなコードは、自然と疎結合になる。

### テストピラミッドの反パターン(アイスクリームコーン)

以下のようなテスト構成は避ける:

- E2Eテストばかりで、ユニットテストが少ない(逆ピラミッド)。
- 統合テストが多く、ユニットテストとE2Eテストが少ない(砂時計型)。

これらは以下の問題を引き起こす:

- テストの実行時間が長くなる(CI/CDのボトルネック)。
- テストが不安定になる(フレイキーテスト)。
- 失敗時の原因特定が困難。
- メンテナンスコストが高い。

## テストの分類

### 単体テスト(Unit Test)

- 個々の関数やクラスの振る舞いをテストする。
- 外部依存は可能な限りモックする。
- 高速に実行できることを重視する(1テスト数ミリ秒〜数十ミリ秒)。
- **テストピラミッドの基盤を構成する(70-80%)**。

### 統合テスト(Integration Test)

- 複数のコンポーネント間の連携をテストする。
- 実際のファイルI/Oやデータベース操作を含む場合がある。
- 単体テストよりも実行時間が長くなることを許容する(1テスト数百ミリ秒〜数秒)。
- **テストピラミッドの中間層を構成する(15-20%)**。

### E2Eテスト(End-to-End Test)

- ユーザーの操作フローを再現するテスト。
- UI操作、データベース、外部API、すべてを含む。
- 実行時間が長く、メンテナンスコストが高い(1テスト数秒〜数十秒)。
- **テストピラミッドの頂点を構成する(5-10%)**。

### 境界値テスト(Boundary Test)

- 正常系と異常系の境界をテストする。
- 日付の境界(0時、23時59分59秒など)。
- 配列の要素数(0件、1件、大量など)。
- 文字列の長さ(空文字、最大長など)。
- **すべてのテストレベル(ユニット、統合、E2E)で実施する**。

### 回帰テスト(Regression Test)

- バグ修正後、同じバグが再発しないことを保証する。
- バグ修正時は必ず再現テストを追加する。
- **すべてのテストレベルで実施する**。

## 不具合対応のTDDプロセス

### バグ発見時の手順

1. **再現テストを書く(Red)**
   - バグが起きた条件を最小限のテストとして追加する。
   - テストが失敗することを確認する。
   - このテストは「仕様どおりなら通るはずなのに落ちる」形で書く。

2. **原因を特定し、最小限の修正で通す(Green)**
   - バグの根本原因を特定する。
   - 必要最小限の修正を行い、テストを通す。
   - 既存のテストも全て通ることを確認する。

3. **必要ならリファクタリング(Refactor)**
   - 修正によってコード構造が悪化していれば、Greenを保ったままリファクタリングする。
   - テストコード自体の改善も行う。

4. **再現テストを永続化**
   - 修正後のテストは削除せず、テストスイートに残す。
   - 将来的に同じバグが再発しないことを保証する。

### バグ対応の注意点

- 「バグは仕様との乖離である」→仕様どおりに動くことを確認するテストが存在しなかったことが原因。
- 「再現テストを書かない修正は再発する」→手動再現だけで終えると、将来また壊れても気づけない。
- 「不具合修正もTDDサイクルの中で扱う」→バグ修正は特別扱いではなく、通常のRed-Green-Refactorループの一部。

## テストカバレッジの方針

### カバレッジ目標

- 行カバレッジ: 80%以上を目標とする。
- 分岐カバレッジ: 主要な分岐は全てカバーする。

### カバレッジの優先順位

1. **高優先度**: ビジネスロジック、データ操作、API境界。
2. **中優先度**: UI コンポーネント、ユーティリティ関数。
3. **低優先度**: 定数定義、型定義、トリビアルなゲッター/セッター。

### カバレッジの落とし穴

- カバレッジ100%が目標ではない。
- カバレッジが高くても、テストの品質が低ければ意味がない。
- 重要なのは「正しい振る舞いをテストしているか」である。

## テストダブル: モックとスタブの使用方針

### テストダブルとは

テストダブルは、テスト対象のコードが依存する外部コンポーネントの代替物である。以下の種類がある:

1. **スタブ(Stub)**: 固定値を返すダミーオブジェクト。
2. **モック(Mock)**: 呼び出しを記録し、期待される呼び出しを検証する。
3. **フェイク(Fake)**: 実際の実装を簡略化したもの(例: インメモリデータベース)。
4. **スパイ(Spy)**: 実際のオブジェクトをラップし、呼び出しを記録する。
5. **ダミー(Dummy)**: 引数を埋めるだけのオブジェクト(使用されない)。

### テストダブルを使用する場合

- **外部APIへのアクセス**: ファイルI/O、ネットワーク、データベース。
- **時間に依存する処理**: 現在時刻の取得、タイムアウト。
- **ランダム性のある処理**: UUID生成、乱数生成。
- **テストが困難な状況**: エラー発生、ネットワーク遅延。

### テストダブルの原則

1. **可能な限り実際のオブジェクトを使用する**
   - テストダブルは必要最小限に留める。
   - 実際のオブジェクトを使えるなら、それを使う。

2. **振る舞いをテストし、実装をテストしない**
   - モックで「どのメソッドが呼ばれたか」を検証しすぎると、実装の詳細に依存する。
   - 「結果として何が得られるか」に焦点を当てる。

3. **スタブを優先し、モックは必要な時だけ使う**
   - スタブ: 状態ベースの検証(返り値を確認)。
   - モック: インタラクションベースの検証(呼び出しを確認)。
   - 多くの場合、スタブで十分。

### Humble Objectパターン

Humble Objectパターンは、テストしにくいコードを分離し、テスト可能にする設計技法である。

**原則:**

- テストしにくい部分(UI、ファイルI/O、外部API)を薄いラッパーに閉じ込める。
- ビジネスロジックを純粋な関数として抽出する。
- ラッパーは「Humble(謙虚)」であり、ロジックを持たない。

**例: ファイル読み込み処理**

修正前(テストしにくい):

```typescript
class MemoManager {
	async loadMemos(filePath: string): Promise<MemoEntry[]> {
		// ファイル読み込み(テストしにくい)。
		const content = await this.app.vault.read(filePath)

		// パース処理(ビジネスロジック、テストしたい)。
		const memos: MemoEntry[] = []
		const lines = content.split("\n")
		for (const line of lines) {
			if (line.startsWith("<!-- memo-id:")) {
				// ... パース処理 ...
				memos.push(parsedMemo)
			}
		}
		return memos
	}
}
```

修正後(Humble Objectパターン適用):

```typescript
// Humble Object: ファイル読み込みのみを担当(テストダブルで置き換える)。
class FileReader {
	constructor(private app: App) {}

	async read(filePath: string): Promise<string> {
		return await this.app.vault.read(filePath)
	}
}

// 純粋な関数: パース処理(テストしやすい)。
function parseMemos(content: string): MemoEntry[] {
	const memos: MemoEntry[] = []
	const lines = content.split("\n")
	for (const line of lines) {
		if (line.startsWith("<!-- memo-id:")) {
			// ... パース処理 ...
			memos.push(parsedMemo)
		}
	}
	return memos
}

// 組み合わせ。
class MemoManager {
	constructor(private fileReader: FileReader) {}

	async loadMemos(filePath: string): Promise<MemoEntry[]> {
		const content = await this.fileReader.read(filePath)
		return parseMemos(content) // 純粋な関数(テストしやすい)。
	}
}

// テスト: parseMemos() は実際のファイルI/Oなしでテストできる。
it("メモをパースできる", () => {
	const content = "<!-- memo-id: 1, timestamp: 2025-10-31T00:00:00Z -->\nテスト"
	const memos = parseMemos(content)
	expect(memos).toHaveLength(1)
	expect(memos[0].id).toBe("1")
})
```

**メリット:**

- `parseMemos()` は純粋な関数なので、高速にテストできる。
- `FileReader` は薄いラッパーなので、テストダブルで簡単に置き換えられる。
- ビジネスロジックとI/Oが分離され、コードが理解しやすい。

## テストの保守性

### DRY原則の適用

- テストコード内でも重複を避ける。
- 共通のセットアップ処理はbeforeEachに移動する。
- テストデータの生成はヘルパー関数に抽出する。

### テストの可読性

- テストコードは「仕様書」として読めること。
- コメントは最小限にし、コード自体が分かりやすいようにする。
- マジックナンバーは避け、定数化する。

### テストの実行速度

- 単体テストは高速に実行できること(1テスト1秒以内を目標)。
- 遅いテストは別ファイルに分離する。
- CI/CDで定期的に全テストを実行する。

## 特定ドメインのテスト方針

### 日付・時刻関連のテスト

- タイムゾーンの扱いに注意する。
- UTC時刻とローカル時刻を明確に区別する。
- 境界値(日をまたぐ時刻、月末、年末、閏年)を必ずテストする。
- 時刻に依存する処理は、固定時刻でテストする。

### ファイルI/O関連のテスト

- 実際のファイルシステムを使わず、モックを使用する。
- ファイルの存在/非存在の両方をテストする。
- ファイル読み込み/書き込みの失敗ケースもテストする。

### データパース関連のテスト

- 正常系だけでなく、異常系もテストする。
- 不正なフォーマットのデータを入力した場合の動作を確認する。
- 境界値(空文字列、巨大な文字列、特殊文字)をテストする。

## テストコードレビューのチェックリスト

- [ ] AAA(Arrange-Act-Assert)パターンに従っているか。
- [ ] テスト名が期待される振る舞いを明確に表しているか。
- [ ] 1つのテストで1つのことだけをテストしているか。
- [ ] テストは独立して実行可能か。
- [ ] 境界値をテストしているか。
- [ ] 異常系をテストしているか。
- [ ] モックは適切に使用されているか(使いすぎていないか)。
- [ ] テストの実行速度は適切か。
- [ ] コメントがなくてもテストの意図が分かるか。
- [ ] マジックナンバーは使われていないか。

## まとめ

- テストは「仕様書」である。テストコードを読めば、システムの振る舞いが分かるようにする。
- テストの数ではなく、テストの品質を重視する。
- TDDのサイクル(Red-Green-Refactor)を守る。
- 不具合修正時は必ず再現テストを追加する。
- テストコードも本番コードと同様に保守する。
